
# Introduction 

## Causal Analisys

### Relevance 

### History

### Numerical Optimisation

## DYNOTEARS

## GOLEM

## DAGMA

# Results

## Synthetic Data

## Real World Data

# Usage

## Run your own

We have provided implementations of DYNOTEARS GOLEMTS and DAGMATS. You can run these on your own datasets or on Synthetic datasets generated by our implementation. We provide two primary methods from running these algorithems, from the main method and from a call to the underlying python function. 

### main.py

You can run each method on generated data or a provided csv file using 'python main.py' comand from the root directory

'python main.py' is followed by the name of the method (DYNOTEARS, GOLEMTS, DAGMATS) followed by arguments specifying the data and output directory.

-p is the number of different times slots in the data and must always be specified

If you are using existing data you give the filename of the csv file under --data as shown below

```rb
python3 main.py GOLEMTS \
                      --data filename.csv \
                      -p 1
```

If no --out paramiter is specified it will write to output.json. If the --out paramiter is specified it will write to that file. The output is a json object containing the original casual graph if known and the estimated causal graph, allowing the user to analise the accuracy.

```rb
python3 main.py GOLEMTS \
                      --data filename.csv \
                      -p 1 \
                      --out new_output.json
```

It can also generate synthetic data using the following two paramiters
* -n number of observations
* -d number of variables
* --degree number of causal relationships to model

The method will then be ran on the synthetic data and the estimated graph will be writen to the output file

```rb
python3 main.py GOLEMTS \
                     -n 10 \
                     -d 3 \
                     -p 1 \
                     --degree 4

python3 main.py  DAGMATS \
                     -n 10 \
                     -d 3 \
                     -p 1 \
                     --degree 4 \

python3 main.py  DYNOTEARS \
                     -n 10 \
                     -d 3 \
                     -p 1 \
                     --degree 4 \
                     --out new_output.json
```


### Direct Python Calls

This method provides the highest degree of custemisation. Each function in formated to take the number of oberservations(n), number of variables per timeslot(d), number of timeslots(p) followed by the data(Y) formated with n rows and d*p columns. After these positional arguments are the particular methods hyperparamiters as discused in the methods section in the introduction. Last is the number of itterations to run(epochs) before returning the best estimate.

* src.train.run_DYNOTEARS(n, d, p, Y, w_thresh=0.01, epochs=100):

* src.train.run_GOLEMTS(n, d, p, Y, lambda_1=0.1, lambda_2=1, ev=True, lr=3e-3, lambda_3=9, epochs=1000, warmup_epochs=0):

* src.train.run_DAGMATS(n, d, p, Y, lambda1=0.01, lambda2=0.03, lr=0.02, w_threshold=0, epochs=1000) 

# Reference
Ng, Ignavier, AmirEmad Ghassami, and Kun Zhang. "On the role of sparsity and dag constraints for learning linear dags." *Advances in Neural Information Processing Systems* 33 (2020): 17943-17954.

Zheng, Xun, et al. "Dags with no tears: Continuous optimization for structure learning." *Advances in neural information processing systems* 31 (2018).

Bello, Kevin, Bryon Aragam, and Pradeep Ravikumar. "Dagma: Learning dags via m-matrices and a log-determinant acyclicity characterization." *Advances in Neural Information Processing Systems* 35 (2022): 8226-8239.

Pamfil, Roxana, et al. "Dynotears: Structure learning from time-series data." International Conference on Artificial Intelligence and Statistics. PMLR, 2020.
